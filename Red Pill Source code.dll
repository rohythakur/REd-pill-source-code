//Red Pill SLC.DLL Source Code
unsigned int InterlockedCompareExchange = 0x77e5bfd4;
__size32 SLSetProductSkuInformation = 0x8b55ff8b;// 4 bytes

void SLSetProductSkuInformation();
void proc1(HMODULE param1, __size32 param2);
void __imp__amsg_exit();
__size32 SLSetProductSkuInformation(__size32 *param1, __size32 param3, __size32 param4, __size32 param4);
void __imp__initterm();

// address: 0x713c5622
void SLSetProductSkuInformation() {
    unsigned int eax;       // r24
    unsigned int eax_1;       // r24{33}
    int eax_2;       // r24{152}
    __size32 *ebp;       // r29
    __size32 *ebp_1;       // r29{8}
    int ebp_2;       // r29{152}
    __size32 ebx;       // r27
    int ebx_1;       // r27{12}
    int ebx_2;       // r27{60}
    __size32 ecx;       // r25
    __size32 edi;       // r31
    unsigned int edi_1;       // r31{15}
    unsigned int edi_2;       // r31{217}
    unsigned int edi_3;       // r31{60}
    __size32 edx;       // r26
    unsigned int esi;       // r30
    unsigned int esi_1;       // r30{174}
    int esi_2;       // r30{46}
    int esi_3;       // r30{18}
    int esi_4;       // r30{216}
    unsigned int esi_5;       // r30{242}
    int esi_6;       // r30{60}
    void *esp;       // r28
    void *esp_1;       // r28{8}
    void *esp_2;       // r28{214}
    int esp_3;       // r28{152}
    void *esp_4;       // r28{131}
    int local0;       // m[esp - 4]
    int local1;       // m[esp - 28]
    __size32 local10;       // m[esp - 8]{247}
    unsigned int local11;       // m[esp - 12]{251}
    int local12;       // m[esp - 16]{267}
    int local13;       // m[esp - 20]{268}
    int local14;       // m[esp - 24]{269}
    int local15;       // m[esp - 28]{270}
    int local16;       // esi_2{192}
    unsigned int local17;       // edi{193}
    int local18;       // ebx_1{201}
    int local19;       // esi_4{204}
    int local2;       // m[esp - 24]
    unsigned int local20;       // edi_2{205}
    __size32 *local21;       // ebp_1{215}
    int local22;       // esi_4{216}
    unsigned int local23;       // edi_2{217}
    void *local24;       // esp_1{230}
    __size32 *local25;       // ebp_1{231}
    unsigned int local26;       // esi_5{242}
    int local3;       // m[esp - 20]
    int local4;       // m[esp - 16]
    unsigned int local5;       // m[esp - 12]
    int local6;       // m[esp - 8]
    __size32 local7;       // m[esp + 8]
    int local8;       // m[esp + 8]{261}
    __size32 local9;       // m[esp - 4]{246}

    local26 = esi_5;
    if (local7 == 1) {
        SLSetProductSkuInformation(local1, local2, local3, local4, edx);
        local26 = esi_1;
    }
    esi_5 = local26;
    SLSetProductSkuInformation(12, ebx, esi_5, edi);
    local24 = esp_1;
    local25 = ebp_1;
    ebx_1 = 1;
    *(__size32*)(ebp_1 - 28) = 1;
    edi_1 = 0;
    *(__size32*)(ebp_1 - 4) = 0;
    esi_3 = *(ebp_1 + 12);
    local16 = esi_3;
    local17 = edi_1;
    local18 = ebx_1;
    local19 = esi_3;
    local20 = edi_1;
    if (esi_3 != 0 || *0x713c7374 != 0) {
        if (esi_3 != 1 && esi_3 != 2) {
L15:
            ebx_1 = local18;
            esi_4 = local19;
            edi_2 = local20;
            *(__size32*)(esp_1 - 4) = *(ebp_1 + 16);
            *(int*)(esp_1 - 8) = esi_4;
            *(__size32*)(esp_1 - 12) = *(ebp_1 + 8);
            proc1(*(esp_1 - 12), *(esp_1 - 8));
            local21 = ebp_1;
            local21 = ebp_1;
            local22 = esi_4;
            local22 = esi_4;
            local23 = edi_2;
            local23 = edi_2;
            *(unsigned int*)(ebp_1 - 28) = eax;
            if ( !(esi_4 != ebx_1 || eax != edi_2)) {
                *(__size32*)(esp_1 - 4) = *(ebp_1 + 16);
                *(unsigned int*)(esp_1 - 8) = edi_2;
                *(__size32*)(esp_1 - 12) = *(ebp_1 + 8);
                proc1(*(esp_1 - 12), *(esp_1 - 8));
                *(__size32*)(esp_1 - 4) = *(ebp_1 + 16);
                *(unsigned int*)(esp_1 - 8) = edi_2;
                *(__size32*)(esp_1 - 12) = *(ebp_1 + 8);
                SLSetProductSkuInformation();
                local21 = ebp;
                local22 = esi;
                local23 = edi;
                eax = *(&SLSetProductSkuInformation + 884);
                if (eax != edi) {
                    local0 = *(ebp + 16);
                    local6 = edi;
                    local5 = *(ebp + 8);
                    (*eax)(local1, local2, local3, local4, local5, local10, local9, local8, eax, ecx, edx, ebx, ebp, esi, edi, SUBFLAGS32(eax, edi, eax - edi), eax - edi == 0, eax < edi);
                    local21 = ebp;
                    local22 = esi;
                    local23 = edi;
                }
            }
            esp_2 = esp;
            ebp_1 = local21;
            esi_4 = local22;
            edi_2 = local23;
            local24 = esp_2;
            local25 = ebp_1;
            if ( !(esi_4 != edi_2 && esi_4 != 3)) {
                *(__size32*)(esp_2 - 4) = *(ebp_1 + 16);
                *(int*)(esp_2 - 8) = esi_4;
                *(__size32*)(esp_2 - 12) = *(ebp_1 + 8);
                SLSetProductSkuInformation();
                local24 = esp_4;
                local24 = esp_4;
                local25 = ebp_1;
                local25 = ebp_1;
                if (eax == 0) {
                    *(unsigned int*)(ebp_1 - 28) = edi;
                }
                if (*(ebp_1 - 28) != edi) {
                    eax = *(&SLSetProductSkuInformation + 884);
                    if (eax != edi) {
                        *(__size32*)(esp_4 - 4) = *(ebp_1 + 16);
                        *(int*)(esp_4 - 8) = esi;
                        *(__size32*)(esp_4 - 12) = *(ebp_1 + 8);
                        (*eax)(local15, local14, local13, local12, local11, local6, local0, local7, eax, ecx, edx, ebx, ebp_1, esi, edi, SUBFLAGS32(eax, edi, eax - edi), eax - edi == 0, eax < edi);
                        local24 = esp_3;
                        local25 = ebp_2;
                        *(unsigned int*)(ebp_2 - 28) = eax_2;
                    }
                }
            }
        } else {
            eax_1 = *(&SLSetProductSkuInformation + 884);
            if (eax_1 != 0) {
                *(__size32*)(esp_1 - 4) = *(ebp_1 + 16);
                *(int*)(esp_1 - 8) = esi_3;
                *(__size32*)(esp_1 - 12) = *(ebp_1 + 8);
                (*eax_1)(local1, local2, local3, local4, pc, 0x713c5ba0, 12, local7, eax_1, ecx, edx, 1, ebp_1, esi_3, 0, SUBFLAGS32(eax_1, 0, eax_1), eax_1 == 0, eax_1 < 0);
                local16 = esi_2;
                local17 = edi;
                *(unsigned int*)(ebp_1 - 28) = eax;
            }
            esi_2 = local16;
            edi = local17;
            local24 = esp_1;
            local25 = ebp_1;
            if (*(ebp_1 - 28) != edi) {
                *(__size32*)(esp_1 - 4) = *(ebp_1 + 16);
                *(int*)(esp_1 - 8) = esi_2;
                *(__size32*)(esp_1 - 12) = *(ebp_1 + 8);
                SLSetProductSkuInformation();
                local18 = ebx_2;
                local19 = esi_6;
                local20 = edi_3;
                local24 = esp_1;
                local25 = ebp_1;
                *(unsigned int*)(ebp_1 - 28) = eax;
                if (eax != edi_3) {
                    goto L15;
                }
            }
        }
    } else {
        *(__size32*)(ebp_1 - 28) = 1;
    }
    esp_1 = local24;
    ebp_1 = local25;
    *(__size32*)(ebp_1 - 4) = -2;
    SLSetProductSkuInformation(ebp_1);
    return;
}

// address: 0x713c54f3
void SLSetProductSkuInformation() {
    __size32 eax;       // r24
    union { void * x177; int x178; } eax_1;       // r24
    void *eax_2;       // r24{322}
    union { void * x171; int x172; } ebp;       // r29
    union { void * x171; int x172; } ebp_1;       // r29
    int ebp_2;       // r29
    union { void * x171; int x172; } ebp_3;       // r29
    union { void * x171; int x172; } ebp_4;       // r29
    union { void * x171; int x172; } ebp_5;       // r29
    int ebx;       // r27
    LONG *ebx_1;       // r27
    LONG *ecx;       // r25
    LONG *ecx_1;       // r25
    int ecx_2;       // r25
    __size32 edi;       // r31
    __size32 edx;       // r26
    unsigned int esi;       // r30
    unsigned int *esp;       // r28
    union { LONG ** x125; int x126; } esp_1;       // r28
    unsigned int *esp_10;       // r28{211}
    LONG **esp_11;       // r28{57}
    unsigned int *esp_12;       // r28{194}
    unsigned int *esp_13;       // r28{314}
    LONG **esp_14;       // r28{274}
    union { LONG ** x173; int x174; } esp_2;       // r28
    union { LONG ** x125; int x126; } esp_3;       // r28
    union { unsigned int * x127; int x128; } esp_4;       // r28
    union { unsigned int * x175; int x176; } esp_5;       // r28
    union { unsigned int * x127; int x128; } esp_6;       // r28
    LONG **esp_7;       // r28{108}
    __size32 *esp_8;       // r28{88}
    LONG **esp_9;       // r28{78}
    int local0;       // m[esp + 8]
    int local1;       // m[esp - 28]
    int local10;       // m[esp + 8]{392}
    int local11;       // m[esp + 8]{164}
    int local12;       // m[esp + 8]{380}
    int local13;       // m[esp + 8]{57}
    __size32 local14;       // m[esp - 4]{393}
    __size32 local15;       // m[esp - 4]{381}
    unsigned int local16;       // m[esp - 8]{394}
    unsigned int local17;       // m[esp - 8]{382}
    unsigned int local18;       // m[esp - 12]{395}
    unsigned int local19;       // m[esp - 12]{383}
    int local2;       // m[esp - 24]
    int local20;       // m[esp - 16]{396}
    int local21;       // m[esp - 16]{164}
    int local22;       // m[esp - 16]{384}
    int local23;       // m[esp - 16]{57}
    int local24;       // m[esp - 20]{397}
    int local25;       // m[esp - 20]{164}
    int local26;       // m[esp - 20]{385}
    int local27;       // m[esp - 20]{57}
    int local28;       // m[esp - 24]{429}
    int local29;       // m[esp - 24]{57}
    int local3;       // m[esp - 20]
    int local30;       // m[esp - 24]{433}
    int local31;       // m[esp - 28]{430}
    int local32;       // m[esp - 28]{57}
    int local33;       // m[esp - 28]{434}
    void *local34;       // m[esp_13 - 4]{204}
    unsigned int local35;       // m[esp_13 - 4]{192}
    union { void * x171; int x172; } local36;       // ebp_1{260}
    LONG **local37;       // esp_14{274}
    union { void * x171; int x172; } local38;       // ebp_4{303}
    unsigned int *local39;       // esp_13{314}
    int local4;       // m[esp - 16]
    unsigned int local5;       // m[esp - 12]
    unsigned int local6;       // m[esp - 8]
    __size32 local7;       // m[esp - 4]
    unsigned int local8;       // m[a[SLSetProductSkuInformation] + 876]{212}
    union { void * x179; int x180; } local9;       // m[a[SLSetProductSkuInformation] + 876]{202}

    if (local0 == 1) {
        edx = SLSetProductSkuInformation(local1, local2, local3, local4, edx);
    }
    ebp = esp - 4;
    eax = 0;
    local36 = ebp;
    local38 = ebp;
    if (local0 != 0) {
L40:
        tmp1 = local0 - 1;
        flags = SUBFLAGS32(local0, 1, tmp1);
        ecx = *0x713c10a4;
        ecx_1 = *ecx;
        *(LONG **)0x713c737c = ecx_1;
        if (local0 != 1) {
            flags = SUBFLAGS32(local0, 0, local0);
            if (local0 == 0) {
                edi = InterlockedCompareExchange;
                esp = esp - 16;
                esi = 0x713c7384;
                for(;;) {
                    ebp_4 = local38;
                    local7 = 1;
                    local6 = esi;
                    (*edi)(local33, local30, local24, local20, local18, local16, local14, local10, eax, ecx, edx, ebx_1, ebp_4, esi, edi, flags, ZF, CF);
                    local38 = ebp_2;
                    local39 = esp_10;
                    flags = LOGICALFLAGS32(eax);
                    if (eax == 0) {
                        break;
                    }
                    *(__size32*)(esp_10 - 4) = 1000;
                    Sleep(*(esp_10 - 4));
                    *(__size32*)(esp_10 - 4) = 0;
                    esp = esp_10 - 4;
                }
                eax = *(&SLSetProductSkuInformation + 868);
                if (eax == 2) {
                    ecx = *(&SLSetProductSkuInformation + 880);
                    edi = 0;
                    if (ecx != 0) {
                        for(;;) {
                            ecx = *0x713c738c;
                            esp_13 = local39;
                            eax = *0x713c7388;
                            do {
                                eax_2 = eax;
                                eax = eax_2 - 4;
                                local9 = eax_2 - 4;
                                if (eax_2 - 4 < ecx) {
                                    break;
                                }
                                tmp1 = *(eax_2 - 4) - edi;
                            } while (*(eax_2 - 4) == edi);
                            (**(eax_2 - 4))(local1, local2, local25, local21, local5, local6, local7, local11, eax_2 - 4, ecx, edx, ebx_1, ebp_2, esi, edi, <all>, SUBFLAGS32(*(eax_2 - 4), edi, tmp1), tmp1 == 0, *(eax_2 - 4) < edi);
                            local39 = esp_12;
                        }
                        local34 = ecx;
                        free(*(esp_13 - 4));
                        esp_10 = esp_13;
                        local8 = edi;
                        *(unsigned int*)(&SLSetProductSkuInformation + 880) = edi;
                    }
                    *(unsigned int*)(esp_10 - 4) = edi;
                    *(unsigned int*)(esp_10 - 8) = esi;
                    *(unsigned int*)(&SLSetProductSkuInformation + 868) = edi;
                    InterlockedExchange(*(esp_10 - 8), *(esp_10 - 4));
                } else {
                    *(__size32*)(esp_10 - 4) = 31;
                    _amsg_exit();
                }
            }
L2:
        } else {
            ecx = *24;
            edi = InterlockedCompareExchange;
            ebx = *(ecx + 4);
            esp_1 = esp - 20;
            esi = 0x713c7384;
            for(;;) {
                ebp_1 = local36;
                local7 = ebx;
                local6 = esi;
                (*edi)(local31, local28, local26, local22, local19, local17, local15, local12, eax, ecx, edx, ebx, ebp_1, esi, edi, flags, ZF, CF);
                local36 = ebp_2;
                if (eax == 0) {
                    goto L32;
                }
                flags = SUBFLAGS32(eax, ebx, eax - ebx);
                if (eax == ebx) {
                    break;
                }
                *(__size32*)(esp_11 - 4) = 1000;
                Sleep(*(esp_11 - 4));
                *(__size32*)(esp_11 - 4) = 0;
                esp = esp_11 - 4;
            }
            *(__size32*)(ebp_2 + 12) = 1;
L32:
            eax = *(&SLSetProductSkuInformation + 868);
            *(__size32*)(esp_11 - 4) = 2;
            edi = *(esp_11 - 4);
            ebx_1 = *esp_11;
            if (eax == 0) {
                *(LONG **)esp_11 = 0x713c10e0;
                *(__size32*)(esp_11 - 4) = 0x713c10d8;
                *(__size32*)(&SLSetProductSkuInformation + 868) = 1;
                eax = SLSetProductSkuInformation(*(esp_11 - 4), ebp_2, esi, edi); /* Warning: also results in esi, esp_8, ebp_2, edi */
                if (eax == 0) {
                    *(__size32*)(esp_8 + 4) = 0x713c10d4;
                    *(__size32*)esp_8 = 0x713c10d0;
                    _initterm();
                    esp_7 = esp_8 + 4;
                    *(unsigned int*)(&SLSetProductSkuInformation + 868) = edi;
                    local37 = esp_7;
L25:
                    esp_14 = local37;
                    ecx = *esp_14;
                    if (*(ebp_2 + 12) == 0) {
                        *(LONG **)esp_14 = 0;
                        *(unsigned int*)(esp_14 - 4) = esi;
                        InterlockedExchange(*(esp_14 - 4), *esp_14);
                    }
                    eax = *(&SLSetProductSkuInformation + 888);
                    if (eax != 0) {
                        *(LONG **)esp_14 = *(ebp_2 + 16);
                        *(unsigned int*)(esp_14 - 4) = edi;
                        *(__size32*)(esp_14 - 8) = *(ebp_2 + 8);
                        (*eax)(local32, local29, local27, local23, local5, local6, local7, local13, eax, ecx, edx, ebx_1, ebp_2, esi, edi, <all>, LOGICALFLAGS32(eax), LOGICALFLAGS32(eax), LOGICALFLAGS32(eax));
                    }
                    *(__size32*)(&SLSetProductSkuInformation + 856)++;
                    goto L2;
                } else {
                }
            } else {
                *(LONG **)esp_11 = 31;
                _amsg_exit();
                local37 = esp_9;
                goto L25;
            }
        }
    } else {
        if (*(&SLSetProductSkuInformation + 856) <= 0) {
        } else {
            *(__size32*)(&SLSetProductSkuInformation + 856) = *(&SLSetProductSkuInformation + 856) - 1;
            goto L40;
        }
    }
    return;
}

// address: 0x713c1ce6
void proc1(HMODULE param1, __size32 param2) {
    if (param2 - 1 == 0) {
        DisableThreadLibraryCalls(param1);
    }
    SetLastError(0);
    return;
}

// address: 0x713c56f8
void __imp__amsg_exit() {
    _amsg_exit();
    return;
}

// address: 0x713c530a
__size32 SLSetProductSkuInformation(__size32 *param1, __size32 param3, __size32 param4, __size32 param4) {
    __size32 eax;       // r24
    union { void * x223; int x224; } ebp;       // r29
    union { void * x223; int x224; } ebp_2;       // r29
    union { void * x223; int x224; } ebp_3;       // r29
    int ebp_4;       // r29
    __size32 ecx;       // r25
    __size32 edi;       // r31
    __size32 *esi;       // r30
    void *esp;       // r28
    __size32 *esp_1;       // r28{47}
    __size32 *esp_2;       // r28{37}
    __size32 *esp_3;       // r28{6}
    __size32 *esp_4;       // r28{21}
    __size32 local0;       // m[esp - 4]
    __size32 local1;       // m[esp - 8]
    __size32 local10;       // m[esp - 8]{60}
    __size32 *local11;       // esp_2{37}
    union { void * x223; int x224; } local12;       // ebp_3{38}
    __size32 local13;       // local7{59}
    __size32 local14;       // local10{60}
    __size32 *local15;       // local4{63}
    __size32 *local16;       // esp_1{47}
    union { void * x223; int x224; } local17;       // ebp_2{48}
    __size32 local18;       // local6{61}
    __size32 local19;       // local9{62}
    __size32 *local2;       // m[esp + 4]
    __size32 *local20;       // local3{64}
    __size32 *local3;       // m[esp + 4]{64}
    __size32 *local4;       // m[esp + 4]{63}
    __size32 local5;       // m[esp - 4]{2}
    __size32 local6;       // m[esp - 4]{61}
    __size32 local7;       // m[esp - 4]{59}
    __size32 local8;       // m[esp - 8]{5}
    __size32 local9;       // m[esp - 8]{62}

    edi = param4;
    local5 = param3;
    ebp = esp - 4;
    local8 = param4;
    esp_3 = esp - 8;
    esi = param1;
    eax = 0;
    local16 = esp_3;
    local17 = ebp;
    local18 = local5;
    local19 = local8;
    local20 = param1;
    esp_1 = local16;
    ebp_2 = local17;
    local6 = local18;
    local9 = local19;
    local3 = local20;
    local11 = esp_1;
    local12 = ebp_2;
    local13 = local6;
    local14 = local9;
    local15 = local3;
    while (esi < *(ebp_2 + 12)) {
        if (eax != 0) {
            break;
        }
        ecx = *esi;
        if (ecx != 0) {
            (*ecx)(local9, local6, local3, eax, ecx, ebp_2, esi, edi, LOGICALFLAGS32(ecx), LOGICALFLAGS32(ecx), LOGICALFLAGS32(ecx));
            local11 = esp_4;
            local12 = ebp_4;
            local13 = local0;
            local14 = local1;
            local15 = local2;
        }
        esp_2 = local11;
        ebp_3 = local12;
        local7 = local13;
        local10 = local14;
        local4 = local15;
        esi++;
        local16 = esp_2;
        local17 = ebp_3;
        local18 = local7;
        local19 = local10;
        local20 = local4;
        esp_1 = local16;
        ebp_2 = local17;
        local6 = local18;
        local9 = local19;
        local3 = local20;
        local11 = esp_1;
        local12 = ebp_2;
        local13 = local6;
        local14 = local9;
        local15 = local3;
    }
    esi = *esp_1;
    ebp_4 = *(esp_1 + 4);
    return eax; /* WARNING: Also returning: esi := esi, ebp_4 := ebp_4, edi := edi */
}

// address: 0x713c56ec
void __imp__initterm() {
    _initterm();
    return;
}
